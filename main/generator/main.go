package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"text/template"
)

const header = "// CODE GENERATED BY  ./main/generator/main.go, .*DO NOT EDIT*."

var (
	structName  string
	unmarshal   bool
	marshal     bool
	destination string
)

func init() {
	flag.StringVar(&structName, "struct", "", "Name of the struct to process")
	flag.StringVar(&destination, "destination", "", "Name of the struct to process")
	flag.BoolVar(&unmarshal, "marshal", false, "Set to true to generate the unmarshal stub")
	flag.BoolVar(&marshal, "unmarshal", false, "Set to true to generate the marshal stub")
	flag.Parse()

	if structName == "" || (!unmarshal && !marshal) || destination == "" {
		fmt.Fprintf(os.Stderr, "Usage: %s -struct <struct_name> [[-marshal] | [-unmarshal] | [-marshal -unmarshal]] -destination <relative_destintion_path>\n", os.Args[0])
		os.Exit(1)
	}

	if filepath.IsAbs(destination) {
		fmt.Fprintf(os.Stderr, "The destination path should be a relative path\n")
	}
}

func main() {
	// Parse the source code of the main project
	fset := token.NewFileSet()
	wd, _ := os.Getwd()
	pkgs, err := parser.ParseDir(fset, wd, nil, parser.ParseComments)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing source code: %s\n", err)
		os.Exit(1)
	}

	// Iterate through packages and files
	for _, pkg := range pkgs {
		for filename, file := range pkg.Files {
			ast.Inspect(file, func(n ast.Node) bool {
				// Check if the node is a struct declaration
				if typeSpec, ok := n.(*ast.TypeSpec); ok {
					if structType, ok := typeSpec.Type.(*ast.StructType); ok {
						// Check if the struct has the specified name
						if typeSpec.Name.Name == structName {
							// @TODO: make sure the attribute of type AdditionalProperties is in struct
							// if not then fail, cannot generate this unmarshal...
							// AdditionalProperties must be written like => {
							//  AdditionalProperties map[string]interface{} `json:"-"`
							// }
							// generatedCode := generateCode(structName, structType, filename, pkg.Name)
							fmt.Println(filename)
							fmt.Println(structType)

							knownProperties := []string{}
							for _, field := range structType.Fields.List {
								jsonTag := ""
								if field.Tag != nil {
									tagValue := reflect.StructTag(field.Tag.Value[1 : len(field.Tag.Value)-1])
									jsonTag = tagValue.Get("json")
									if jsonTag != "-" {
										knownProperties = append(knownProperties, jsonTag)
									}
								}
							}

							code := generateCodeSteps(
								generateHeader,
								generateImportGenerator([]string{"encoding/json"}),
								generateUnmarshalCodeGenerator(structName, knownProperties),
							)

							formattedCode, err := format.Source(code)
							if err != nil {
								fmt.Fprintf(os.Stderr, "Error formatting generated code: %s\n", err)
								os.Exit(1)
							}

							fmt.Printf("%s\n", formattedCode)
							os.Exit(0)
						}
					}
				}
				return true
			})
		}
	}

	fmt.Fprintf(os.Stderr, "Struct with name %s not found\n", structName)
	os.Exit(1)
}

type step func() []byte

func generateCodeSteps(steps ...step) []byte {
	var buf bytes.Buffer

	for _, step := range steps {
		fmt.Fprintf(&buf, "%s\n", step())
	}

	return buf.Bytes()
}

func generateHeader() []byte {
	return []byte(fmt.Sprintf("%s\n", header))
}

func generateImportGenerator(imports []string) step {
	return func() []byte {
		var buf bytes.Buffer
		buf.Write([]byte("import (\n"))

		for _, i := range imports {
			buf.Write([]byte(fmt.Sprintf("\t\"%s\"\n", i)))
		}

		buf.Write([]byte(")\n"))

		return buf.Bytes()
	}
}

func generateUnmarshalCodeGenerator(structName string, knownProperties []string) step {
	var buf bytes.Buffer

	content := &struct {
		StructName      string
		KnownProperties []string
	}{
		StructName:      structName,
		KnownProperties: knownProperties,
	}

	unmarshalTemplate := `func (s {{.StructName}}) UnmarshallJSON(data []byte) error {
    // The reason for using this approach is to avoid an infinite loop during
    // JSON unmarshaling. When unmarshaling JSON into this struct, the
    // UnmarshalJSON method is called. Without the alias and embedded
    // struct, it would call itself recursively, leading to a stack overflow.

    // By using an alias and an embedded struct, we break the recursion,
    // and the UnmarshalJSON method can be applied to the embedded
    // *Alias field without triggering another call to the same method.

	aux := &struct {
		*Alias
	}{
		Alias: (*Alias)(it),
	}

	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}

	var m map[string]interface{}
	if err := json.Unmarshal(data, &m); err != nil {
		return err
	}

	s.AdditionalProperties = make(map[string]interface{})
    for key, value := range m {
        switch key {
        case {{$x := join .KnownProperties ", "}}{{$x}}:
            // Skip known fields...
        default:
            s.AdditionalProperties[key] = value
        }
    }

    return nil
}
`

	t := template.New("unmarshal-" + structName).Funcs(template.FuncMap{
		"join": func(s []string, sep string) string {
			for k := range s {
				s[k] = fmt.Sprintf("\"%s\"", s[k])
			}
			return strings.Join(s, sep)
		},
	})
	t = template.Must(t.Parse(unmarshalTemplate))
	_ = t.Execute(&buf, content)

	// formattedCode, err := format.Source(buf.Bytes())
	// if err != nil {
	// 	fmt.Fprintf(os.Stderr, "Error formatting generated code: %s\n", err)
	// 	os.Exit(1)
	// }

	return func() []byte {
		return buf.Bytes()
	}
}
