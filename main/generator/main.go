// generator.go

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"text/template"
)

const header = "// CODE GENERATED BY  ./main/generator/main.go, .*DO NOT EDIT*."

var (
	structName  string
	unmarshal   bool
	marshal     bool
	destination string
)

func init() {
	flag.StringVar(&structName, "struct", "", "Name of the struct to process")
	flag.StringVar(&destination, "destination", "", "Name of the struct to process")
	flag.BoolVar(&unmarshal, "marshal", false, "Set to true to generate the unmarshal stub")
	flag.BoolVar(&marshal, "unmarshal", false, "Set to true to generate the marshal stub")
	flag.Parse()

	if structName == "" || (!unmarshal && !marshal) || destination == "" {
		fmt.Fprintf(os.Stderr, "Usage: %s -struct <struct_name> [[-marshal] | [-unmarshal] | [-marshal -unmarshal]] -destination <relative_destintion_path>\n", os.Args[0])
		os.Exit(1)
	}

	if filepath.IsAbs(destination) {
		fmt.Fprintf(os.Stderr, "The destination path should be a relative path\n")
	}
}

func main() {
	// Parse the source code of the main project
	fset := token.NewFileSet()
	wd, _ := os.Getwd()
	pkgs, err := parser.ParseDir(fset, wd, nil, parser.ParseComments)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing source code: %s\n", err)
		os.Exit(1)
	}

	// Iterate through packages and files
	for _, pkg := range pkgs {
		for filename, file := range pkg.Files {
			ast.Inspect(file, func(n ast.Node) bool {
				// Check if the node is a struct declaration
				if typeSpec, ok := n.(*ast.TypeSpec); ok {
					if structType, ok := typeSpec.Type.(*ast.StructType); ok {
						// Check if the struct has the specified name
						if typeSpec.Name.Name == structName {
							// @TODO: make sure the attribute of type AdditionalProperties is in struct
							// if not then fail, cannot generate this unmarshal...
							// AdditionalProperties must be written like => {
							//  AdditionalProperties map[string]interface{} `json:"-"`
							// }
							// generatedCode := generateCode(structName, structType, filename, pkg.Name)
							fmt.Println(filename)
							fmt.Println(structType)

							knownProperties := []string{}
							for _, field := range structType.Fields.List {
								jsonTag := ""
								if field.Tag != nil {
									tagValue := reflect.StructTag(field.Tag.Value[1 : len(field.Tag.Value)-1])
									jsonTag = tagValue.Get("json")
									if jsonTag != "-" {
										knownProperties = append(knownProperties, jsonTag)
									}
								}
							}

							code := generateCodeSteps(generateHeader, generateImportGenerator([]string{"hello", "wolrd"}))

							// generatedUnmarshal := generateUnmarshalCode(structName, knownProperties)
							fmt.Printf("%s\n", code)
							os.Exit(0)
						}
					}
				}
				return true
			})
		}
	}

	fmt.Fprintf(os.Stderr, "Struct with name %s not found\n", structName)
	os.Exit(1)
}

type step func() []byte

func generateCodeSteps(steps ...step) []byte {
	res := []byte{}
	var buf bytes.Buffer

    for _, step := range steps {
	    buf.Write(step())
        fmt.Printf("%s\n", step())
	}

	return res
}

func generateHeader() []byte {
	return []byte(header)
}

func generateImportGenerator(imports []string) step {
	return func() []byte {
		var buf bytes.Buffer
		buf.Write([]byte("import (\n"))

		for _, i := range imports {
			buf.Write([]byte(fmt.Sprintf("\t\"%s\"\n", i)))
		}

		buf.Write([]byte(")\n"))

		return buf.Bytes()
	}
}

func generateCode(structName string, structType *ast.StructType, filename string, packageName string) string {
	// Example: Generate code that prints the struct's name, full file path, attributes, and JSON tags
	//absPath, err := filepath.Abs(filename)
	// if err != nil {
	//	fmt.Fprintf(os.Stderr, "Error getting absolute path: %s\n", err)
	//	os.Exit(1)
	// }

	var buf bytes.Buffer

	fmt.Fprintf(&buf, "// CODE GENERATED BY  ./main/generator/main.go, .*DO NOT EDIT*.") //	fmt.Fprintf(&buf, "package %s\n\n", packageName)	fmt.Fprintf(&buf, "import \"encoding/json\"\n\n")   fmt.Fprintf(&buf, "func main() {\n")    fmt.Fprintf(&buf, "\t%s := %s{}\n", strings.ToLower(structName), structName)	fmt.Fprintf(&buf, "\tfmt.Printf(\"%s: %%+v\\n\", %s)\n", structName, strings.ToLower(structName))	fmt.Fprintf(&buf, "\tfmt.Printf(\"File path: %s\\n\")\n", absPath)

	// Iterate through struct fields and print their attributes and JSON tags
	for _, field := range structType.Fields.List {
		fieldName := field.Names[0].Name
		// fieldType := field.Type

		// Extract JSON tags, if present
		jsonTag := ""
		if field.Tag != nil {
			tagValue := reflect.StructTag(field.Tag.Value[1 : len(field.Tag.Value)-1])
			jsonTag = tagValue.Get("json")
		}

		// Print field attributes and JSON tags
		fmt.Fprintf(&buf, "\tfmt.Printf(\"Field: %s, Type: %%T, JSON Tag: %s\\n\", %s.%s)\n", fieldName, jsonTag, strings.ToLower(structName), fieldName)
	}

	fmt.Fprintf(&buf, "}\n")

	// Format the generated code
	formattedCode, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error formatting generated code: %s\n", err)
		os.Exit(1)
	}

	return string(formattedCode)
}

// func generateCommonCode(packages string) []byte {
//
// }

func generateUnmarshalCode(structName string, knownProperties []string) []byte {
	var buf bytes.Buffer

	content := &struct {
		StructName      string
		KnownProperties []string
	}{
		StructName:      structName,
		KnownProperties: knownProperties,
	}

	unmarshalTemplate := `func (s {{.StructName}}) UnmarshallJSON(data []byte) error {
    // The reason for using this approach is to avoid an infinite loop during
    // JSON unmarshaling. When unmarshaling JSON into this struct, the
    // UnmarshalJSON method is called. Without the alias and embedded
    // struct, it would call itself recursively, leading to a stack overflow.

    // By using an alias and an embedded struct, we break the recursion,
    // and the UnmarshalJSON method can be applied to the embedded
    // *Alias field without triggering another call to the same method.

	aux := &struct {
		*Alias
	}{
		Alias: (*Alias)(it),
	}

	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}

	var m map[string]interface{}
	if err := json.Unmarshal(data, &m); err != nil {
		return err
	}

	s.AdditionalProperties = make(map[string]interface{})
    for key, value := range m {
        switch key {
        case {{$x := join .KnownProperties ", "}}{{$x}}:
            // Skip known fields...
        default:
            s.AdditionalProperties[key] = value
        }
    }

    return nil
}
`

	t := template.New("unmarshal-" + structName).Funcs(template.FuncMap{
		"join": func(s []string, sep string) string {
			for k := range s {
				s[k] = fmt.Sprintf("\"%s\"", s[k])
			}
			return strings.Join(s, sep)
		},
	})
	t = template.Must(t.Parse(unmarshalTemplate))
	_ = t.Execute(&buf, content)

	formattedCode, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error formatting generated code: %s\n", err)
		os.Exit(1)
	}

	return formattedCode
}
