package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"text/template"
)

const header = "// CODE GENERATED BY ./main/generator/main.go, DO NOT EDIT"

var (
	structName string
	unmarshal  bool
	// marshal     bool
	destination string
)

func init() {
	flag.StringVar(&structName, "struct", "", "Name of the struct to process")
	flag.StringVar(&destination, "destination", "", "Name of the struct to process")
	flag.BoolVar(&unmarshal, "unmarshal", false, "Set to true to generate the unmarshal stub")
	// Not required at the moment, when required remove comment
	// flag.BoolVar(&marshal, "marshal", false, "Set to true to generate the marshal stub")
	flag.Parse()

	if structName == "" || !unmarshal || destination == "" {
		fmt.Fprintf(os.Stderr, "Usage: %s -struct <struct_name> -unmarshal -destination <relative_destintion_path>\n", os.Args[0])
		os.Exit(1)
	}

	if filepath.IsAbs(destination) {
		fmt.Fprintf(os.Stderr, "The destination path should be a relative path\n")
	}
}

func main() {
	fullPath, _ := filepath.Abs(os.Getenv("GOFILE"))

	fset := token.NewFileSet()
	parsedFile, _ := parser.ParseFile(fset, fullPath, nil, parser.ParseComments)

	knownProperties := []string{}

	var errs error

	// This function should be used to check weather or not the required action
	// for the selected struct are allowed, if some validation error occurs
	// then an error should be returned.
	inspectFunction := func(n ast.Node) bool {
		var typeSpec *ast.TypeSpec
		var ok bool
		if typeSpec, ok = n.(*ast.TypeSpec); !ok {
			return true
		}

		if typeSpec.Name.Name != structName {
			return true
		}

		var structType *ast.StructType
		if structType, ok = typeSpec.Type.(*ast.StructType); !ok {
			return true
		}

		// Validating for unmarshal action
		for _, field := range structType.Fields.List {
			if field.Tag == nil {
				errs = errors.Join(errs, fmt.Errorf("in %s struct, missing tag for the %v field", structName, field.Names))
				continue
			}

			tagValue := reflect.StructTag(field.Tag.Value[1 : len(field.Tag.Value)-1])

			jsonKey := tagValue.Get("json")

			if jsonKey == "" {
				errs = errors.Join(errs, fmt.Errorf("in %s struct, JSON tag is not set for the %v field", structName, field.Names))
				continue
			}

			if jsonKey != "-" {
				knownProperties = append(knownProperties, jsonKey)
				continue
			}

			switch t := field.Type.(type) {
			case *ast.MapType:
				_, isString := t.Key.(*ast.Ident)
				_, isInterface := t.Value.(*ast.InterfaceType)
				if !isString || !isInterface {
					errs = errors.Join(errs, fmt.Errorf("in %s struct, expected to have %v field having JSON tag \"-\" to be of type map[string]interface{}", structName, field.Names))
				}
			default:
				errs = errors.Join(errs, fmt.Errorf("in %s struct, expected to have %v field having JSON tag \"-\" to be of type map[string]interface{}", structName, field.Names))
			}
		}

		return false
	}

	ast.Inspect(parsedFile, inspectFunction)

	if errs != nil {
		fmt.Fprintf(os.Stderr, "some errors occured validating the requested actions for the %s struct: %s\n", structName, errs)
		os.Exit(1)
	}

	code := generateCodeSteps(
		generateHeader,
		generateImportGenerator([]string{"encoding/json"}),
		generateUnmarshalCodeGenerator(structName, knownProperties),
	)

	formattedCode, err := format.Source(code)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error formatting generated code: %s\n", err)
		os.Exit(1)
	}

	fmt.Printf("%s\n", formattedCode)
    // @TODO: Save formatted code to the specified destination path...
}

type step func() []byte

func generateCodeSteps(steps ...step) []byte {
	var buf bytes.Buffer

	for _, step := range steps {
		fmt.Fprintf(&buf, "%s\n", step())
	}

	return buf.Bytes()
}

func generateHeader() []byte {
	return []byte(fmt.Sprintf("%s\n", header))
}

func generateImportGenerator(imports []string) step {
	return func() []byte {
		var buf bytes.Buffer
		buf.Write([]byte("import (\n"))

		for _, i := range imports {
			buf.Write([]byte(fmt.Sprintf("\t\"%s\"\n", i)))
		}

		buf.Write([]byte(")\n"))

		return buf.Bytes()
	}
}

func generateUnmarshalCodeGenerator(structName string, knownProperties []string) step {
	var buf bytes.Buffer

	content := &struct {
		StructName      string
		KnownProperties []string
	}{
		StructName:      structName,
		KnownProperties: knownProperties,
	}

	unmarshalTemplate := `func (s {{.StructName}}) UnmarshallJSON(data []byte) error {
    // The reason for using this approach is to avoid an infinite loop during
    // JSON unmarshaling. When unmarshaling JSON into this struct, the
    // UnmarshalJSON method is called. Without the alias and embedded
    // struct, it would call itself recursively, leading to a stack overflow.

    // By using an alias and an embedded struct, we break the recursion,
    // and the UnmarshalJSON method can be applied to the embedded
    // *Alias field without triggering another call to the same method.

	aux := &struct {
		*Alias
	}{
		Alias: (*Alias)(it),
	}

	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}

	var m map[string]interface{}
	if err := json.Unmarshal(data, &m); err != nil {
		return err
	}

	s.AdditionalProperties = make(map[string]interface{})
    for key, value := range m {
        switch key {
        case {{$x := join .KnownProperties ",\n"}}{{$x}}:
            // Skip known fields...
        default:
            s.AdditionalProperties[key] = value
        }
    }

    return nil
}
`

	t := template.New("unmarshal-" + structName).Funcs(template.FuncMap{
		"join": func(s []string, sep string) string {
			for k := range s {
				s[k] = fmt.Sprintf("\"%s\"", s[k])
			}
			return strings.Join(s, sep)
		},
	})
	t = template.Must(t.Parse(unmarshalTemplate))
	_ = t.Execute(&buf, content)

	return func() []byte {
		return buf.Bytes()
	}
}

// func canGenerateUnmarshall(isAdditionalPropertiesDeclared) bool {
//     return
// }
