package generator

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"
)

const header = "// CODE GENERATED BY ./main/generator/main.go, DO NOT EDIT"

type Step func() []byte

func GenerateCodeSteps(steps ...Step) []byte {
	var buf bytes.Buffer

	for _, step := range steps {
		fmt.Fprintf(&buf, "%s\n", step())
	}

	return buf.Bytes()
}

func GenerateHeader() []byte {
	return []byte(fmt.Sprintf("%s\n", header))
}

func GeneratePackageGenerator(packageName string) Step {
	return func() []byte {
		return []byte(fmt.Sprintf("package %s\n\n", packageName))
	}
}

func GenerateImportGenerator(imports []string) Step {
	return func() []byte {
		var buf bytes.Buffer
		buf.Write([]byte("import (\n"))

		for _, i := range imports {
			buf.Write([]byte(fmt.Sprintf("\t\"%s\"\n", i)))
		}

		buf.Write([]byte(")\n"))

		return buf.Bytes()
	}
}

func GenerateUnmarshalCodeGenerator(structName string, knownProperties []string) Step {
	var buf bytes.Buffer

	content := &struct {
		StructName      string
		KnownProperties []string
	}{
		StructName:      structName,
		KnownProperties: knownProperties,
	}

	unmarshalTemplate := `func (s *{{.StructName}}) UnmarshalJSON(data []byte) error {
    // The reason for using this approach is to avoid an infinite loop during
    // JSON unmarshaling. When unmarshaling JSON into this struct, the
    // UnmarshalJSON method is called. Without the alias and embedded
    // struct, it would call itself recursively, leading to a stack overflow.

    // By using an alias and an embedded struct, we break the recursion,
    // and the UnmarshalJSON method can be applied to the embedded
    // *Alias field without triggering another call to the same method.

    type Alias {{.StructName}}
	aux := &struct {
		*Alias
	}{
		Alias: (*Alias)(s),
	}

	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}

	var m map[string]interface{}
	if err := json.Unmarshal(data, &m); err != nil {
		return err
	}

	s.AdditionalProperties = make(map[string]interface{})
    for key, value := range m {
        switch key {
        case {{$x := join .KnownProperties ",\n"}}{{$x}}:
            // Skip known fields...
        default:
            s.AdditionalProperties[key] = value
        }
    }

    return nil
}
`

	t := template.New("unmarshal-" + structName).Funcs(template.FuncMap{
		"join": func(s []string, sep string) string {
			for k := range s {
				s[k] = fmt.Sprintf("\"%s\"", s[k])
			}
			return strings.Join(s, sep)
		},
	})
	t = template.Must(t.Parse(unmarshalTemplate))
	_ = t.Execute(&buf, content)

	return func() []byte {
		return buf.Bytes()
	}
}
